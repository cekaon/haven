/******************************************************************************
 *     "Copyright (C) 2013, ApS s.r.o Brno, All Rights Reserved"             *
 ******************************************************************************/
/**
 *  \file
 *  \date   Thu Jan 17 15:32:01 2013, generated by Codasip HW generator v1.6.0.
 *  \brief  Contains declaration of all interfaces.
 */

// Interface of register file 'codix_ca_core_regs'.
interface icodix_ca_core_regs ( input logic CLK, input logic RST );

	// member signals
	logic [4:0] codix_ca_core_regs_RA0;
	logic codix_ca_core_regs_RE0;
	logic [4:0] codix_ca_core_regs_RA1;
	logic codix_ca_core_regs_RE1;
	logic [4:0] codix_ca_core_regs_RA2;
	logic codix_ca_core_regs_RE2;
	logic [31:0] codix_ca_core_regs_D0;
	logic codix_ca_core_regs_WE0;
	logic [4:0] codix_ca_core_regs_WA0;
	logic [31:0] codix_ca_core_regs_Q0;
	logic [31:0] codix_ca_core_regs_Q1;
	logic [31:0] codix_ca_core_regs_Q2;
	wire logic [31:0] codix_ca_core_regs_init[0:31];
	// Clocking blocks
	clocking cb @(posedge CLK);
		output codix_ca_core_regs_RA0, codix_ca_core_regs_RE0, codix_ca_core_regs_RA1, codix_ca_core_regs_RE1, codix_ca_core_regs_RA2, codix_ca_core_regs_RE2, codix_ca_core_regs_D0, codix_ca_core_regs_WE0, codix_ca_core_regs_WA0;
		input  codix_ca_core_regs_Q0, codix_ca_core_regs_Q1, codix_ca_core_regs_Q2;
	endclocking: cb;
	// Coverage clocking blocks
	clocking cover_cb @(posedge CLK);
		input codix_ca_core_regs_RA0, codix_ca_core_regs_RE0, codix_ca_core_regs_RA1, codix_ca_core_regs_RE1, codix_ca_core_regs_RA2, codix_ca_core_regs_RE2, codix_ca_core_regs_D0, codix_ca_core_regs_WE0, codix_ca_core_regs_WA0, codix_ca_core_regs_Q0, codix_ca_core_regs_Q1, codix_ca_core_regs_Q2;
	endclocking: cover_cb;
	// Control modport
	modport regs( input codix_ca_core_regs_RA0, input codix_ca_core_regs_RE0, input codix_ca_core_regs_RA1, input codix_ca_core_regs_RE1, input codix_ca_core_regs_RA2, input codix_ca_core_regs_RE2, input codix_ca_core_regs_D0, input codix_ca_core_regs_WE0, input codix_ca_core_regs_WA0, output codix_ca_core_regs_Q0, output codix_ca_core_regs_Q1, output codix_ca_core_regs_Q2 );
	modport regs_tb( clocking cb );
endinterface : icodix_ca_core_regs

// Input interface for decoder 'codix_ca_core_main_instr_hw_instr_hw'.
interface icodix_ca_core_main_instr_hw_instr_hw ( input logic CLK, input logic RST );

	logic codix_ca_core_main_instr_hw_instr_hw_ACT;
	logic [11:0] codix_ca_core_main_instr_hw_instr_hw_id_instr_Q0;
	// Clocking blocks
	clocking cb @(posedge CLK);
		output codix_ca_core_main_instr_hw_instr_hw_ACT, codix_ca_core_main_instr_hw_instr_hw_id_instr_Q0;
	endclocking: cb;
	// Coverage clocking blocks
	clocking cover_cb @(posedge CLK);
		input codix_ca_core_main_instr_hw_instr_hw_ACT, codix_ca_core_main_instr_hw_instr_hw_id_instr_Q0;
	endclocking: cover_cb;
	// Control modport
	modport main_instr_hw_instr_hw_in( input codix_ca_core_main_instr_hw_instr_hw_ACT, input codix_ca_core_main_instr_hw_instr_hw_id_instr_Q0 );
	modport main_instr_hw_instr_hw_in_tb( clocking cb );
endinterface : icodix_ca_core_main_instr_hw_instr_hw

// Interface of memory 'mem'.
interface icodix_ca_mem ( input logic CLK, input logic RST );

	// member signals
	logic [12:0] codix_ca_mem_RA0;
	logic codix_ca_mem_RE0;
	logic [2:0] codix_ca_mem_RSC0;
	logic [1:0] codix_ca_mem_RSI0;
	logic [12:0] codix_ca_mem_RA1;
	logic codix_ca_mem_RE1;
	logic [2:0] codix_ca_mem_RSC1;
	logic [1:0] codix_ca_mem_RSI1;
	logic [31:0] codix_ca_mem_D0;
	logic codix_ca_mem_WE0;
	logic [12:0] codix_ca_mem_WA0;
	logic [2:0] codix_ca_mem_WSC0;
	logic [1:0] codix_ca_mem_WSI0;
	logic [31:0] codix_ca_mem_Q0;
	logic [2:0] codix_ca_mem_RR0;
	logic [2:0] codix_ca_mem_FR0;
	logic [31:0] codix_ca_mem_Q1;
	logic [2:0] codix_ca_mem_RR1;
	logic [2:0] codix_ca_mem_FR1;
	logic [2:0] codix_ca_mem_RW0;
	logic [2:0] codix_ca_mem_FW0;
	// Clocking blocks
	clocking cb @(posedge CLK);
		output codix_ca_mem_RA0, codix_ca_mem_RE0, codix_ca_mem_RSC0, codix_ca_mem_RSI0, codix_ca_mem_RA1, codix_ca_mem_RE1, codix_ca_mem_RSC1, codix_ca_mem_RSI1, codix_ca_mem_D0, codix_ca_mem_WE0, codix_ca_mem_WA0, codix_ca_mem_WSC0, codix_ca_mem_WSI0;
		input  codix_ca_mem_Q0, codix_ca_mem_RR0, codix_ca_mem_FR0, codix_ca_mem_Q1, codix_ca_mem_RR1, codix_ca_mem_FR1, codix_ca_mem_RW0, codix_ca_mem_FW0;
	endclocking: cb;
	// Coverage clocking blocks
	clocking cover_cb @(posedge CLK);
		input codix_ca_mem_RA0, codix_ca_mem_RE0, codix_ca_mem_RSC0, codix_ca_mem_RSI0, codix_ca_mem_RA1, codix_ca_mem_RE1, codix_ca_mem_RSC1, codix_ca_mem_RSI1, codix_ca_mem_D0, codix_ca_mem_WE0, codix_ca_mem_WA0, codix_ca_mem_WSC0, codix_ca_mem_WSI0, codix_ca_mem_Q0, codix_ca_mem_RR0, codix_ca_mem_FR0, codix_ca_mem_Q1, codix_ca_mem_RR1, codix_ca_mem_FR1, codix_ca_mem_RW0, codix_ca_mem_FW0;
	endclocking: cover_cb;
	// Control modport
	modport mem( input codix_ca_mem_RA0, input codix_ca_mem_RE0, input codix_ca_mem_RSC0, input codix_ca_mem_RSI0, input codix_ca_mem_RA1, input codix_ca_mem_RE1, input codix_ca_mem_RSC1, input codix_ca_mem_RSI1, input codix_ca_mem_D0, input codix_ca_mem_WE0, input codix_ca_mem_WA0, input codix_ca_mem_WSC0, input codix_ca_mem_WSI0, output codix_ca_mem_Q0, output codix_ca_mem_RR0, output codix_ca_mem_FR0, output codix_ca_mem_Q1, output codix_ca_mem_RR1, output codix_ca_mem_FR1, output codix_ca_mem_RW0, output codix_ca_mem_FW0 );
	modport mem_tb( clocking cb );
endinterface : icodix_ca_mem

// Interface with port(s) used to activate halt functional unit(s) from main controller(s)
interface ihalt ( input logic CLK, input logic RST );

	logic codix_ca_core_main_controller_main_halt_halt_fu_semantics_ACT;
	// Clocking blocks
	clocking cb @(posedge CLK);
		input  codix_ca_core_main_controller_main_halt_halt_fu_semantics_ACT;
	endclocking: cb;
	// Coverage clocking blocks
	clocking cover_cb @(posedge CLK);
		input codix_ca_core_main_controller_main_halt_halt_fu_semantics_ACT;
	endclocking: cover_cb;
	// Control modport
	modport codix_ca( output codix_ca_core_main_controller_main_halt_halt_fu_semantics_ACT );
	modport codix_ca_tb( clocking cb );
	// indicate whether halt is activate or not
	function bit is_active();
		return codix_ca_core_main_controller_main_halt_halt_fu_semantics_ACT;
	endfunction: is_active
endinterface : ihalt

// DUT input interface
interface icodix_ca_in ( input logic CLK, input logic RST,
	input wire codix_ca_irq );

	// private variables needed for continuous assignment
	logic m_codix_ca_irq;
	// assign values to inputs
	assign codix_ca_irq = m_codix_ca_irq;
	// functions to set values on input ports
	function void set_codix_ca_irq( input logic value );
		m_codix_ca_irq = value;
	endfunction : set_codix_ca_irq
	// Clocking blocks
	clocking cb @(posedge CLK);
		output codix_ca_irq;
	endclocking: cb;
	// Coverage clocking blocks
	clocking cover_cb @(posedge CLK);
		input codix_ca_irq;
	endclocking: cover_cb;
	// Control modport
	modport codix_ca( input codix_ca_irq );
	modport codix_ca_tb( clocking cb );
endinterface : icodix_ca_in

// DUT output interface
interface icodix_ca_out ( input logic CLK, input logic RST );

	logic codix_ca_port_halt;
	logic [31:0] codix_ca_port_output;
	logic codix_ca_port_output_en;
	logic [31:0] codix_ca_port_error;
	// Clocking blocks
	clocking cb @(posedge CLK);
		input  codix_ca_port_halt, codix_ca_port_output, codix_ca_port_output_en, codix_ca_port_error;
	endclocking: cb;
	// Coverage clocking blocks
	clocking cover_cb @(posedge CLK);
		input codix_ca_port_halt, codix_ca_port_output, codix_ca_port_output_en, codix_ca_port_error;
	endclocking: cover_cb;
	// Control modport
	modport codix_ca_out( output codix_ca_port_halt, output codix_ca_port_output, output codix_ca_port_output_en, output codix_ca_port_error );
	modport codix_ca_out_tb( clocking cb );
endinterface : icodix_ca_out

