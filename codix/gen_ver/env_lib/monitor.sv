/******************************************************************************
 *     "Copyright (C) 2013, ApS s.r.o Brno, All Rights Reserved"             *
 ******************************************************************************/
/**
 *  \file
 *  \date   Thu Jan 17 15:32:01 2013, generated by Codasip HW generator v1.6.0.
 *  \brief  Definitions of all monitors needed.
 */

// This class is used to compare register file content with reference results and to monitor its usage.
class codix_ca_core_regs_monitor extends ovm_monitor;

	// interface wrapper with references to every interface
	local DutIfWrapper if_wrapper;
	// analysis port for sending data receive from out/inout interface to the connected scoreboard
	ovm_analysis_port #(codix_ca_core_regs_transaction) analysis_export;

	// registration of component tools
	`ovm_component_utils_begin( codix_ca_core_regs_monitor )
		`ovm_field_object( if_wrapper, OVM_DEFAULT | OVM_NOCOMPARE | OVM_NOPRINT | OVM_NORECORD | OVM_NOPACK )
	`ovm_component_utils_end

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
	endfunction: new

	// build - instantiates child components
	function void build;
		super.build();
		analysis_export = new( "analysis_export", this );
	endfunction: build

	// run - starts the processing in monitor
	task run();
		// do not monitor interface during reset.
		@( posedge if_wrapper.icodix_ca_core_regs_if.RST );
		// from now on, monitor interface every clock cycle
		forever
		begin
			automatic codix_ca_core_regs_transaction tr = new( "dut_codix_ca_core_regs_transaction" );
			// synchronize with the DUT
			@( if_wrapper.icodix_ca_core_regs_if.cb );
			// receive interface port values
			tr.codix_ca_core_regs_RA0 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_RA0;
			tr.codix_ca_core_regs_RE0 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_RE0;
			tr.codix_ca_core_regs_RA1 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_RA1;
			tr.codix_ca_core_regs_RE1 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_RE1;
			tr.codix_ca_core_regs_RA2 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_RA2;
			tr.codix_ca_core_regs_RE2 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_RE2;
			tr.codix_ca_core_regs_D0 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_D0;
			tr.codix_ca_core_regs_WE0 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_WE0;
			tr.codix_ca_core_regs_WA0 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_WA0;
			tr.codix_ca_core_regs_Q0 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_Q0;
			tr.codix_ca_core_regs_Q1 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_Q1;
			tr.codix_ca_core_regs_Q2 = if_wrapper.icodix_ca_core_regs_if.cover_cb.codix_ca_core_regs_Q2;
			// display the content of the transaction
			// tr.print();
			// send it to the scoreboard, subscriber, ...
			analysis_export.write( tr );
		end
	endtask: run

	// extract - access the array content and send it to scoreboard
	function void extract();
		// create new transaction
		automatic codix_ca_core_regs_transaction tr = new( "dut_codix_ca_core_regs_transaction");
		// save array content
		tr.codix_ca_core_regs_init = new[32](if_wrapper.icodix_ca_core_regs_if.codix_ca_core_regs_init );
		// and send it to the scoreboard
		analysis_export.write( tr );
	endfunction: extract

endclass: codix_ca_core_regs_monitor

// This class is used to monitor instructions handled by the decoder.
class codix_ca_core_main_instr_hw_instr_hw_monitor extends ovm_monitor;

	// interface wrapper with references to every interface
	local DutIfWrapper if_wrapper;
	// analysis port for sending data receive from out/inout interface to the connected scoreboard
	ovm_analysis_port #(codix_ca_core_main_instr_hw_instr_hw_transaction) analysis_export;

	// registration of component tools
	`ovm_component_utils_begin( codix_ca_core_main_instr_hw_instr_hw_monitor )
		`ovm_field_object( if_wrapper, OVM_DEFAULT | OVM_NOCOMPARE | OVM_NOPRINT | OVM_NORECORD | OVM_NOPACK )
	`ovm_component_utils_end

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
	endfunction: new

	// build - instantiates child components
	function void build;
		super.build();
		analysis_export = new( "analysis_export", this );
	endfunction: build

	// run - starts the processing in monitor
	task run();
		// do not monitor interface during reset.
		@( posedge if_wrapper.icodix_ca_core_main_instr_hw_instr_hw_if.RST );
		// from now on, monitor interface every clock cycle
		forever
		begin
			automatic codix_ca_core_main_instr_hw_instr_hw_transaction tr = new( "dut_codix_ca_core_main_instr_hw_instr_hw_transaction" );
			// synchronize with the DUT
			@( if_wrapper.icodix_ca_core_main_instr_hw_instr_hw_if.cb );
			// receive interface port values
			tr.codix_ca_core_main_instr_hw_instr_hw_ACT = if_wrapper.icodix_ca_core_main_instr_hw_instr_hw_if.cover_cb.codix_ca_core_main_instr_hw_instr_hw_ACT;
			tr.codix_ca_core_main_instr_hw_instr_hw_id_instr_Q0 = if_wrapper.icodix_ca_core_main_instr_hw_instr_hw_if.cover_cb.codix_ca_core_main_instr_hw_instr_hw_id_instr_Q0;
			// display the content of the transaction
			// tr.print();
			// send it to the scoreboard, subscriber, ...
			analysis_export.write( tr );
		end
	endtask: run

endclass: codix_ca_core_main_instr_hw_instr_hw_monitor

// This class is used to monitor memory usage (what addresses, data, ... were used).
class codix_ca_mem_monitor extends ovm_monitor;

	// interface wrapper with references to every interface
	local DutIfWrapper if_wrapper;
	// analysis port for sending data receive from out/inout interface to the connected scoreboard
	ovm_analysis_port #(codix_ca_mem_transaction) analysis_export;

	// registration of component tools
	`ovm_component_utils_begin( codix_ca_mem_monitor )
		`ovm_field_object( if_wrapper, OVM_DEFAULT | OVM_NOCOMPARE | OVM_NOPRINT | OVM_NORECORD | OVM_NOPACK )
	`ovm_component_utils_end

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
	endfunction: new

	// build - instantiates child components
	function void build;
		super.build();
		analysis_export = new( "analysis_export", this );
	endfunction: build

	// run - starts the processing in monitor
	task run();
		// do not monitor interface during reset.
		@( posedge if_wrapper.icodix_ca_mem_if.RST );
		// from now on, monitor interface every clock cycle
		forever
		begin
			automatic codix_ca_mem_transaction tr = new( "dut_codix_ca_mem_transaction" );
			// synchronize with the DUT
			@( if_wrapper.icodix_ca_mem_if.cb );
			// receive interface port values
			tr.codix_ca_mem_RA0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RA0;
			tr.codix_ca_mem_RE0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RE0;
			tr.codix_ca_mem_RSC0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RSC0;
			tr.codix_ca_mem_RSI0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RSI0;
			tr.codix_ca_mem_RA1 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RA1;
			tr.codix_ca_mem_RE1 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RE1;
			tr.codix_ca_mem_RSC1 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RSC1;
			tr.codix_ca_mem_RSI1 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RSI1;
			tr.codix_ca_mem_D0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_D0;
			tr.codix_ca_mem_WE0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_WE0;
			tr.codix_ca_mem_WA0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_WA0;
			tr.codix_ca_mem_WSC0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_WSC0;
			tr.codix_ca_mem_WSI0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_WSI0;
			tr.codix_ca_mem_Q0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_Q0;
			tr.codix_ca_mem_RR0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RR0;
			tr.codix_ca_mem_FR0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_FR0;
			tr.codix_ca_mem_Q1 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_Q1;
			tr.codix_ca_mem_RR1 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RR1;
			tr.codix_ca_mem_FR1 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_FR1;
			tr.codix_ca_mem_RW0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_RW0;
			tr.codix_ca_mem_FW0 = if_wrapper.icodix_ca_mem_if.cover_cb.codix_ca_mem_FW0;
			// display the content of the transaction
			// tr.print();
			// send it to the scoreboard, subscriber, ...
			analysis_export.write( tr );
		end
	endtask: run

endclass: codix_ca_mem_monitor

// This class is used to monitor input ports of the DUT/DUV.
class codix_ca_input_monitor extends ovm_monitor;

	// interface wrapper with references to every interface
	local DutIfWrapper if_wrapper;
	// analysis port for sending data receive from out/inout interface to the connected scoreboard
	ovm_analysis_port #(codix_ca_input_transaction) analysis_export;

	// registration of component tools
	`ovm_component_utils_begin( codix_ca_input_monitor )
		`ovm_field_object( if_wrapper, OVM_DEFAULT | OVM_NOCOMPARE | OVM_NOPRINT | OVM_NORECORD | OVM_NOPACK )
	`ovm_component_utils_end

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
	endfunction: new

	// build - instantiates child components
	function void build;
		super.build();
		analysis_export = new( "analysis_export", this );
	endfunction: build

	// run - starts the processing in monitor
	task run();
		// do not monitor interface during reset.
		@( posedge if_wrapper.icodix_ca_in_if.RST );
		// from now on, monitor interface every clock cycle
		forever
		begin
			automatic codix_ca_input_transaction tr = new( "dut_codix_ca_input_transaction" );
			// synchronize with the DUT
			@( if_wrapper.icodix_ca_in_if.cb );
			// receive interface port values
			tr.codix_ca_irq = if_wrapper.icodix_ca_in_if.cover_cb.codix_ca_irq;
			// display the content of the transaction
			// tr.print();
			// send it to the scoreboard, subscriber, ...
			analysis_export.write( tr );
		end
	endtask: run

endclass: codix_ca_input_monitor

// This class is used to monitor output ports of the DUT/DUV.
class codix_ca_output_monitor extends ovm_monitor;

	// interface wrapper with references to every interface
	local DutIfWrapper if_wrapper;
	// analysis port for sending data receive from out/inout interface to the connected scoreboard
	ovm_analysis_port #(codix_ca_output_transaction) analysis_export;

	// registration of component tools
	`ovm_component_utils_begin( codix_ca_output_monitor )
		`ovm_field_object( if_wrapper, OVM_DEFAULT | OVM_NOCOMPARE | OVM_NOPRINT | OVM_NORECORD | OVM_NOPACK )
	`ovm_component_utils_end

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
	endfunction: new

	// build - instantiates child components
	function void build;
		super.build();
		analysis_export = new( "analysis_export", this );
	endfunction: build

	// run - starts the processing in monitor
	task run();
		// do not monitor interface during reset.
		@( posedge if_wrapper.icodix_ca_out_if.RST );
		// from now on, monitor interface every clock cycle
		forever
		begin
			automatic codix_ca_output_transaction tr = new( "dut_codix_ca_output_transaction" );
			// synchronize with the DUT
			@( if_wrapper.icodix_ca_out_if.cb );
			// receive interface port values
			tr.codix_ca_port_halt = if_wrapper.icodix_ca_out_if.cover_cb.codix_ca_port_halt;
			tr.codix_ca_port_output = if_wrapper.icodix_ca_out_if.cover_cb.codix_ca_port_output;
			tr.codix_ca_port_output_en = if_wrapper.icodix_ca_out_if.cover_cb.codix_ca_port_output_en;
			tr.codix_ca_port_error = if_wrapper.icodix_ca_out_if.cover_cb.codix_ca_port_error;
			// display the content of the transaction
			// tr.print();
			// send it to the scoreboard, subscriber, ...
			analysis_export.write( tr );
		end
	endtask: run

endclass: codix_ca_output_monitor

