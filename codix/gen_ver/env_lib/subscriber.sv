/******************************************************************************
 *     "Copyright (C) 2013, ApS s.r.o Brno, All Rights Reserved"             *
 ******************************************************************************/
/**
 *  \file
 *  \date   Thu Jan 17 15:32:01 2013, generated by Codasip HW generator v1.6.0.
 *  \brief  Definitions of all subscribers to collect coverage.
 */

// This class measures exercised combinations of interface signals.
class codix_ca_core_regs_subscriber extends ovm_subscriber #(codix_ca_core_regs_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_core_regs_subscriber )

	// member attributes, equivalent with interface ports
	local logic [4:0] codix_ca_core_regs_RA0;
	local logic codix_ca_core_regs_RE0;
	local logic [4:0] codix_ca_core_regs_RA1;
	local logic codix_ca_core_regs_RE1;
	local logic [4:0] codix_ca_core_regs_RA2;
	local logic codix_ca_core_regs_RE2;
	local logic [31:0] codix_ca_core_regs_D0;
	local logic codix_ca_core_regs_WE0;
	local logic [4:0] codix_ca_core_regs_WA0;
	local logic [31:0] codix_ca_core_regs_Q0;
	local logic [31:0] codix_ca_core_regs_Q1;
	local logic [31:0] codix_ca_core_regs_Q2;

	// Covergroup definition
	covergroup FunctionalCoverage;

		readAddress0 : coverpoint codix_ca_core_regs_RA0;

		readEnable0 : coverpoint codix_ca_core_regs_RE0 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		readAddress1 : coverpoint codix_ca_core_regs_RA1;

		readEnable1 : coverpoint codix_ca_core_regs_RE1 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		readAddress2 : coverpoint codix_ca_core_regs_RA2;

		readEnable2 : coverpoint codix_ca_core_regs_RE2 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		input_port_0 : coverpoint codix_ca_core_regs_D0 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		writeEnable0 : coverpoint codix_ca_core_regs_WE0 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		writeAddress0 : coverpoint codix_ca_core_regs_WA0;

		output_port_0 : coverpoint codix_ca_core_regs_Q0 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		output_port_1 : coverpoint codix_ca_core_regs_Q1 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		output_port_2 : coverpoint codix_ca_core_regs_Q2 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		valid_readAddress0: cross readAddress0, readEnable0 {
			// illegal values
			ignore_bins readAddress0_ignore_values = binsof(readEnable0.enable0);
		}
		valid_readAddress1: cross readAddress1, readEnable1 {
			// illegal values
			ignore_bins readAddress1_ignore_values = binsof(readEnable1.enable0);
		}
		valid_readAddress2: cross readAddress2, readEnable2 {
			// illegal values
			ignore_bins readAddress2_ignore_values = binsof(readEnable2.enable0);
		}
		valid_input_port_0: cross input_port_0, writeEnable0 {
			// illegal values
			ignore_bins input_port_0_ignore_values = binsof(writeEnable0.enable0);
		}
		valid_writeAddress0: cross writeAddress0, writeEnable0 {
			// illegal values
			ignore_bins writeAddress0_ignore_values = binsof(writeEnable0.enable0);
		}
		valid_output_port_0: cross output_port_0, readEnable0 {
			// illegal values
			ignore_bins output_port_0_ignore_values = binsof(readEnable0.enable0);
		}
		valid_output_port_1: cross output_port_1, readEnable1 {
			// illegal values
			ignore_bins output_port_1_ignore_values = binsof(readEnable1.enable0);
		}
		valid_output_port_2: cross output_port_2, readEnable2 {
			// illegal values
			ignore_bins output_port_2_ignore_values = binsof(readEnable2.enable0);
		}
		// per instance statistics
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction: build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_core_regs_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			codix_ca_core_regs_RA0 = t.codix_ca_core_regs_RA0;
			codix_ca_core_regs_RE0 = t.codix_ca_core_regs_RE0;
			codix_ca_core_regs_RA1 = t.codix_ca_core_regs_RA1;
			codix_ca_core_regs_RE1 = t.codix_ca_core_regs_RE1;
			codix_ca_core_regs_RA2 = t.codix_ca_core_regs_RA2;
			codix_ca_core_regs_RE2 = t.codix_ca_core_regs_RE2;
			codix_ca_core_regs_D0 = t.codix_ca_core_regs_D0;
			codix_ca_core_regs_WE0 = t.codix_ca_core_regs_WE0;
			codix_ca_core_regs_WA0 = t.codix_ca_core_regs_WA0;
			codix_ca_core_regs_Q0 = t.codix_ca_core_regs_Q0;
			codix_ca_core_regs_Q1 = t.codix_ca_core_regs_Q1;
			codix_ca_core_regs_Q2 = t.codix_ca_core_regs_Q2;
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_core_regs_subscriber

// This class collects instruction coverage.
class codix_ca_core_main_instr_hw_instr_hw_subscriber extends ovm_subscriber #(codix_ca_core_main_instr_hw_instr_hw_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_core_main_instr_hw_instr_hw_subscriber )

	// enumeration type of all instruction used to collect instruction coverage
	`include "decoder.sv"

	// Covergroup definition
	covergroup FunctionalCoverage;

		instructions : coverpoint instruction;
		instr_after_instr : coverpoint instruction {
			bins instr_after_instr[] = ([instruction.first():instruction.last()] => [0:$]);
		}
		// per instance statistics
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction: build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_core_main_instr_hw_instr_hw_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			$cast( instruction, decoder(t.codix_ca_core_main_instr_hw_instr_hw_id_instr_Q0) );
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_core_main_instr_hw_instr_hw_subscriber

// This class measures exercised combinations of interface signals.
class codix_ca_mem_subscriber extends ovm_subscriber #(codix_ca_mem_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_mem_subscriber )

	// member attributes, equivalent with interface ports
	local logic [12:0] codix_ca_mem_RA0;
	local logic codix_ca_mem_RE0;
	local logic [2:0] codix_ca_mem_RSC0;
	local logic [1:0] codix_ca_mem_RSI0;
	local logic [12:0] codix_ca_mem_RA1;
	local logic codix_ca_mem_RE1;
	local logic [2:0] codix_ca_mem_RSC1;
	local logic [1:0] codix_ca_mem_RSI1;
	local logic [31:0] codix_ca_mem_D0;
	local logic codix_ca_mem_WE0;
	local logic [12:0] codix_ca_mem_WA0;
	local logic [2:0] codix_ca_mem_WSC0;
	local logic [1:0] codix_ca_mem_WSI0;
	local logic [31:0] codix_ca_mem_Q0;
	local logic [2:0] codix_ca_mem_RR0;
	local logic [2:0] codix_ca_mem_FR0;
	local logic [31:0] codix_ca_mem_Q1;
	local logic [2:0] codix_ca_mem_RR1;
	local logic [2:0] codix_ca_mem_FR1;
	local logic [2:0] codix_ca_mem_RW0;
	local logic [2:0] codix_ca_mem_FW0;

	// Covergroup definition
	covergroup FunctionalCoverage;

		readAddress0 : coverpoint codix_ca_mem_RA0;

		readEnable0 : coverpoint codix_ca_mem_RE0 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		readSubblockCount0 : coverpoint codix_ca_mem_RSC0;

		readSubblockIndex0 : coverpoint codix_ca_mem_RSI0;

		readAddress1 : coverpoint codix_ca_mem_RA1;

		readEnable1 : coverpoint codix_ca_mem_RE1 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		readSubblockCount1 : coverpoint codix_ca_mem_RSC1;

		readSubblockIndex1 : coverpoint codix_ca_mem_RSI1;

		input_port_0 : coverpoint codix_ca_mem_D0 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		writeEnable0 : coverpoint codix_ca_mem_WE0 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		writeAddress0 : coverpoint codix_ca_mem_WA0;

		writeSubblockCount0 : coverpoint codix_ca_mem_WSC0;

		writeSubblockIndex0 : coverpoint codix_ca_mem_WSI0;

		output_port_0 : coverpoint codix_ca_mem_Q0 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		output_port_1 : coverpoint codix_ca_mem_Q1 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		valid_readAddress0: cross readAddress0, readEnable0 {
			// illegal values
			ignore_bins readAddress0_ignore_values = binsof(readEnable0.enable0);
		}
		valid_readSubblockCount0: cross readSubblockCount0, readEnable0 {
			// illegal values
			ignore_bins readSubblockCount0_ignore_values = binsof(readEnable0.enable0);
		}
		valid_readSubblockIndex0: cross readSubblockIndex0, readEnable0 {
			// illegal values
			ignore_bins readSubblockIndex0_ignore_values = binsof(readEnable0.enable0);
		}
		valid_readAddress1: cross readAddress1, readEnable1 {
			// illegal values
			ignore_bins readAddress1_ignore_values = binsof(readEnable1.enable0);
		}
		valid_readSubblockCount1: cross readSubblockCount1, readEnable1 {
			// illegal values
			ignore_bins readSubblockCount1_ignore_values = binsof(readEnable1.enable0);
		}
		valid_readSubblockIndex1: cross readSubblockIndex1, readEnable1 {
			// illegal values
			ignore_bins readSubblockIndex1_ignore_values = binsof(readEnable1.enable0);
		}
		valid_input_port_0: cross input_port_0, writeEnable0 {
			// illegal values
			ignore_bins input_port_0_ignore_values = binsof(writeEnable0.enable0);
		}
		valid_writeAddress0: cross writeAddress0, writeEnable0 {
			// illegal values
			ignore_bins writeAddress0_ignore_values = binsof(writeEnable0.enable0);
		}
		valid_writeSubblockCount0: cross writeSubblockCount0, writeEnable0 {
			// illegal values
			ignore_bins writeSubblockCount0_ignore_values = binsof(writeEnable0.enable0);
		}
		valid_writeSubblockIndex0: cross writeSubblockIndex0, writeEnable0 {
			// illegal values
			ignore_bins writeSubblockIndex0_ignore_values = binsof(writeEnable0.enable0);
		}
		valid_output_port_0: cross output_port_0, readEnable0 {
			// illegal values
			ignore_bins output_port_0_ignore_values = binsof(readEnable0.enable0);
		}
		valid_output_port_1: cross output_port_1, readEnable1 {
			// illegal values
			ignore_bins output_port_1_ignore_values = binsof(readEnable1.enable0);
		}
		// per instance statistics
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction: build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_mem_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			codix_ca_mem_RA0 = t.codix_ca_mem_RA0;
			codix_ca_mem_RE0 = t.codix_ca_mem_RE0;
			codix_ca_mem_RSC0 = t.codix_ca_mem_RSC0;
			codix_ca_mem_RSI0 = t.codix_ca_mem_RSI0;
			codix_ca_mem_RA1 = t.codix_ca_mem_RA1;
			codix_ca_mem_RE1 = t.codix_ca_mem_RE1;
			codix_ca_mem_RSC1 = t.codix_ca_mem_RSC1;
			codix_ca_mem_RSI1 = t.codix_ca_mem_RSI1;
			codix_ca_mem_D0 = t.codix_ca_mem_D0;
			codix_ca_mem_WE0 = t.codix_ca_mem_WE0;
			codix_ca_mem_WA0 = t.codix_ca_mem_WA0;
			codix_ca_mem_WSC0 = t.codix_ca_mem_WSC0;
			codix_ca_mem_WSI0 = t.codix_ca_mem_WSI0;
			codix_ca_mem_Q0 = t.codix_ca_mem_Q0;
			codix_ca_mem_RR0 = t.codix_ca_mem_RR0;
			codix_ca_mem_FR0 = t.codix_ca_mem_FR0;
			codix_ca_mem_Q1 = t.codix_ca_mem_Q1;
			codix_ca_mem_RR1 = t.codix_ca_mem_RR1;
			codix_ca_mem_FR1 = t.codix_ca_mem_FR1;
			codix_ca_mem_RW0 = t.codix_ca_mem_RW0;
			codix_ca_mem_FW0 = t.codix_ca_mem_FW0;
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_mem_subscriber

// This class measures exercised combinations of DUTs input interface ports.
class codix_ca_input_subscriber extends ovm_subscriber #(codix_ca_input_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_input_subscriber )

	// member attributes, equivalent with interface ports
	local logic codix_ca_irq;

	// Covergroup definition
	covergroup FunctionalCoverage;

		input_port_irq : coverpoint codix_ca_irq {
			bins zeros        = {0};
			bins ones         = {'b1};
		}

		// per instance statistics
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction: build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_input_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			codix_ca_irq = t.codix_ca_irq;
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_input_subscriber

// This class measures exercised combinations of DUTs output interface ports.
class codix_ca_output_subscriber extends ovm_subscriber #(codix_ca_output_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_output_subscriber )

	// member attributes, equivalent with interface ports
	local logic codix_ca_port_halt;
	local logic [31:0] codix_ca_port_output;
	local logic codix_ca_port_output_en;
	local logic [31:0] codix_ca_port_error;

	// Covergroup definition
	covergroup FunctionalCoverage;

		output_port_port_halt : coverpoint codix_ca_port_halt {
			bins zeros        = {0};
			bins ones         = {'b1};
		}

		output_port_port_output : coverpoint codix_ca_port_output {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		output_port_port_output_en : coverpoint codix_ca_port_output_en {
			bins zeros        = {0};
			bins ones         = {'b1};
		}

		output_port_port_error : coverpoint codix_ca_port_error {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:'b1111]};
			bins big_values   = {['b1111111111111111111111111111:'b11111111111111111111111111111111]};
			bins other_values = default;
		}

		// per instance statistics
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction: build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_output_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			codix_ca_port_halt = t.codix_ca_port_halt;
			codix_ca_port_output = t.codix_ca_port_output;
			codix_ca_port_output_en = t.codix_ca_port_output_en;
			codix_ca_port_error = t.codix_ca_port_error;
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_output_subscriber

