/******************************************************************************
 *     "Copyright (C) 2013, ApS s.r.o Brno, All Rights Reserved"             *
 ******************************************************************************/
/**
 *  \file
 *  \date   Mon Mar  4 13:49:04 2013, generated by Codasip HW generator v2.0.0.
 *  \brief  Definitions of all subscribers to collect coverage.
 */

// This class measures exercised combinations of interface signals.
class codix_ca_core_regs_subscriber extends ovm_subscriber #(codix_ca_core_regs_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_core_regs_subscriber )

	// member attributes, equivalent with interface ports
	local logic [4:0] codix_ca_core_regs_RA0;
	local logic codix_ca_core_regs_RE0;
	local logic [4:0] codix_ca_core_regs_RA1;
	local logic codix_ca_core_regs_RE1;
	local logic [4:0] codix_ca_core_regs_RA2;
	local logic codix_ca_core_regs_RE2;
	local logic [31:0] codix_ca_core_regs_D0;
	local logic codix_ca_core_regs_WE0;
	local logic [4:0] codix_ca_core_regs_WA0;
	local logic [31:0] codix_ca_core_regs_Q0;
	local logic [31:0] codix_ca_core_regs_Q1;
	local logic [31:0] codix_ca_core_regs_Q2;

	// Covergroup definition
	covergroup FunctionalCoverage;

		cvp_regs_RA0 : coverpoint codix_ca_core_regs_RA0 {
			option.auto_bin_max = 5;
		}

		cvp_regs_RE0 : coverpoint codix_ca_core_regs_RE0 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		cvp_regs_RA1 : coverpoint codix_ca_core_regs_RA1 {
			option.auto_bin_max = 5;
		}

		cvp_regs_RE1 : coverpoint codix_ca_core_regs_RE1 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		cvp_regs_RA2 : coverpoint codix_ca_core_regs_RA2 {
			option.auto_bin_max = 5;
		}

		cvp_regs_RE2 : coverpoint codix_ca_core_regs_RE2 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		cvp_regs_D0 : coverpoint codix_ca_core_regs_D0 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		cvp_regs_WE0 : coverpoint codix_ca_core_regs_WE0 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		cvp_regs_WA0 : coverpoint codix_ca_core_regs_WA0 {
			option.auto_bin_max = 5;
		}

		cvp_regs_Q0 : coverpoint codix_ca_core_regs_Q0 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		cvp_regs_Q1 : coverpoint codix_ca_core_regs_Q1 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		cvp_regs_Q2 : coverpoint codix_ca_core_regs_Q2 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		cvp_regs_Q0_valid : cross cvp_regs_Q0, cvp_regs_RE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_regs_RE0.enable0);
		}
		cvp_regs_RA0_valid : cross cvp_regs_RA0, cvp_regs_RE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_regs_RE0.enable0);
		}
		cvp_regs_Q1_valid : cross cvp_regs_Q1, cvp_regs_RE1 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_regs_RE1.enable0);
		}
		cvp_regs_RA1_valid : cross cvp_regs_RA1, cvp_regs_RE1 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_regs_RE1.enable0);
		}
		cvp_regs_Q2_valid : cross cvp_regs_Q2, cvp_regs_RE2 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_regs_RE2.enable0);
		}
		cvp_regs_RA2_valid : cross cvp_regs_RA2, cvp_regs_RE2 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_regs_RE2.enable0);
		}
		cvp_regs_D0_valid : cross cvp_regs_D0, cvp_regs_WE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_regs_WE0.enable0);
		}
		cvp_regs_WA0_valid : cross cvp_regs_WA0, cvp_regs_WE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_regs_WE0.enable0);
		}
		// per instance statistics
		option.detect_overlap = 1;
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction : build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_core_regs_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			codix_ca_core_regs_RA0 = t.codix_ca_core_regs_RA0;
			codix_ca_core_regs_RE0 = t.codix_ca_core_regs_RE0;
			codix_ca_core_regs_RA1 = t.codix_ca_core_regs_RA1;
			codix_ca_core_regs_RE1 = t.codix_ca_core_regs_RE1;
			codix_ca_core_regs_RA2 = t.codix_ca_core_regs_RA2;
			codix_ca_core_regs_RE2 = t.codix_ca_core_regs_RE2;
			codix_ca_core_regs_D0 = t.codix_ca_core_regs_D0;
			codix_ca_core_regs_WE0 = t.codix_ca_core_regs_WE0;
			codix_ca_core_regs_WA0 = t.codix_ca_core_regs_WA0;
			codix_ca_core_regs_Q0 = t.codix_ca_core_regs_Q0;
			codix_ca_core_regs_Q1 = t.codix_ca_core_regs_Q1;
			codix_ca_core_regs_Q2 = t.codix_ca_core_regs_Q2;
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_core_regs_subscriber

// This class collects instruction coverage.
class codix_ca_core_main_instr_hw_instr_hw_subscriber extends ovm_subscriber #(codix_ca_core_main_instr_hw_instr_hw_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_core_main_instr_hw_instr_hw_subscriber )

	// contains definition of decoding function with declaration of the enumeration
	// type of all instruction used to collect instruction coverage
	`include "codix_ca_core_main_instr_hw_instr_hw.sv"

	// current instruction
	local operation_codes_t instruction;

	// Covergroup definition
	covergroup FunctionalCoverage;

		instructions : coverpoint instruction;
		instr_after_instr : coverpoint instruction {
			bins instr_after_instr[] = ([instruction.first():instruction.last()] => [0:$]);
		}
		// per instance statistics
		option.detect_overlap = 1;
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction : build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_core_main_instr_hw_instr_hw_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			$cast( instruction, decode(t.codix_ca_core_main_instr_hw_instr_hw_id_instr_Q0) );
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_core_main_instr_hw_instr_hw_subscriber

// This class measures exercised combinations of interface signals.
class codix_ca_mem_subscriber extends ovm_subscriber #(codix_ca_mem_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_mem_subscriber )

	// member attributes, equivalent with interface ports
	local logic [18:0] codix_ca_mem_RA0;
	local logic codix_ca_mem_RE0;
	local logic [2:0] codix_ca_mem_RSC0;
	local logic [1:0] codix_ca_mem_RSI0;
	local logic [18:0] codix_ca_mem_RA1;
	local logic codix_ca_mem_RE1;
	local logic [2:0] codix_ca_mem_RSC1;
	local logic [1:0] codix_ca_mem_RSI1;
	local logic [31:0] codix_ca_mem_D0;
	local logic codix_ca_mem_WE0;
	local logic [18:0] codix_ca_mem_WA0;
	local logic [2:0] codix_ca_mem_WSC0;
	local logic [1:0] codix_ca_mem_WSI0;
	local logic [31:0] codix_ca_mem_Q0;
	local logic [2:0] codix_ca_mem_RR0;
	local logic [2:0] codix_ca_mem_FR0;
	local logic [31:0] codix_ca_mem_Q1;
	local logic [2:0] codix_ca_mem_RR1;
	local logic [2:0] codix_ca_mem_FR1;
	local logic [2:0] codix_ca_mem_RW0;
	local logic [2:0] codix_ca_mem_FW0;

	// Covergroup definition
	covergroup FunctionalCoverage;

		cvp_mem_RA0 : coverpoint codix_ca_mem_RA0 {
			option.auto_bin_max = 19;
		}

		cvp_mem_RE0 : coverpoint codix_ca_mem_RE0 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		cvp_mem_RSC0 : coverpoint codix_ca_mem_RSC0 {
			option.auto_bin_max = 3;
		}

		cvp_mem_RSI0 : coverpoint codix_ca_mem_RSI0 {
			option.auto_bin_max = 2;
		}

		cvp_mem_RA1 : coverpoint codix_ca_mem_RA1 {
			option.auto_bin_max = 19;
		}

		cvp_mem_RE1 : coverpoint codix_ca_mem_RE1 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		cvp_mem_RSC1 : coverpoint codix_ca_mem_RSC1 {
			option.auto_bin_max = 3;
		}

		cvp_mem_RSI1 : coverpoint codix_ca_mem_RSI1 {
			option.auto_bin_max = 2;
		}

		cvp_mem_D0 : coverpoint codix_ca_mem_D0 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		cvp_mem_WE0 : coverpoint codix_ca_mem_WE0 {
			bins enable0 = {0};
			bins enable1 = {1};
		}

		cvp_mem_WA0 : coverpoint codix_ca_mem_WA0 {
			option.auto_bin_max = 19;
		}

		cvp_mem_WSC0 : coverpoint codix_ca_mem_WSC0 {
			option.auto_bin_max = 3;
		}

		cvp_mem_WSI0 : coverpoint codix_ca_mem_WSI0 {
			option.auto_bin_max = 2;
		}

		cvp_mem_Q0 : coverpoint codix_ca_mem_Q0 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		cvp_mem_Q1 : coverpoint codix_ca_mem_Q1 {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		cvp_mem_Q0_valid : cross cvp_mem_Q0, cvp_mem_RE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_RE0.enable0);
		}
		cvp_mem_RA0_valid : cross cvp_mem_RA0, cvp_mem_RE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_RE0.enable0);
		}
		cvp_mem_RSI0_valid : cross cvp_mem_RSI0, cvp_mem_RE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_RE0.enable0);
		}
		cvp_mem_RSC0_valid : cross cvp_mem_RSC0, cvp_mem_RE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_RE0.enable0);
		}
		cvp_mem_Q1_valid : cross cvp_mem_Q1, cvp_mem_RE1 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_RE1.enable0);
		}
		cvp_mem_RA1_valid : cross cvp_mem_RA1, cvp_mem_RE1 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_RE1.enable0);
		}
		cvp_mem_RSI1_valid : cross cvp_mem_RSI1, cvp_mem_RE1 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_RE1.enable0);
		}
		cvp_mem_RSC1_valid : cross cvp_mem_RSC1, cvp_mem_RE1 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_RE1.enable0);
		}
		cvp_mem_D0_valid : cross cvp_mem_D0, cvp_mem_WE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_WE0.enable0);
		}
		cvp_mem_WA0_valid : cross cvp_mem_WA0, cvp_mem_WE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_WE0.enable0);
		}
		cvp_mem_WSI0_valid : cross cvp_mem_WSI0, cvp_mem_WE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_WE0.enable0);
		}
		cvp_mem_WSC0_valid : cross cvp_mem_WSC0, cvp_mem_WE0 {
			// ignore values when enable signal is not set
			ignore_bins ignored_values = binsof(cvp_mem_WE0.enable0);
		}
		// per instance statistics
		option.detect_overlap = 1;
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction : build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_mem_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			codix_ca_mem_RA0 = t.codix_ca_mem_RA0;
			codix_ca_mem_RE0 = t.codix_ca_mem_RE0;
			codix_ca_mem_RSC0 = t.codix_ca_mem_RSC0;
			codix_ca_mem_RSI0 = t.codix_ca_mem_RSI0;
			codix_ca_mem_RA1 = t.codix_ca_mem_RA1;
			codix_ca_mem_RE1 = t.codix_ca_mem_RE1;
			codix_ca_mem_RSC1 = t.codix_ca_mem_RSC1;
			codix_ca_mem_RSI1 = t.codix_ca_mem_RSI1;
			codix_ca_mem_D0 = t.codix_ca_mem_D0;
			codix_ca_mem_WE0 = t.codix_ca_mem_WE0;
			codix_ca_mem_WA0 = t.codix_ca_mem_WA0;
			codix_ca_mem_WSC0 = t.codix_ca_mem_WSC0;
			codix_ca_mem_WSI0 = t.codix_ca_mem_WSI0;
			codix_ca_mem_Q0 = t.codix_ca_mem_Q0;
			codix_ca_mem_RR0 = t.codix_ca_mem_RR0;
			codix_ca_mem_FR0 = t.codix_ca_mem_FR0;
			codix_ca_mem_Q1 = t.codix_ca_mem_Q1;
			codix_ca_mem_RR1 = t.codix_ca_mem_RR1;
			codix_ca_mem_FR1 = t.codix_ca_mem_FR1;
			codix_ca_mem_RW0 = t.codix_ca_mem_RW0;
			codix_ca_mem_FW0 = t.codix_ca_mem_FW0;
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_mem_subscriber

// This class measures exercised combinations of DUTs input interface ports.
class codix_ca_input_subscriber extends ovm_subscriber #(codix_ca_input_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_input_subscriber )

	// member attributes, equivalent with interface ports
	local logic codix_ca_irq;

	// Covergroup definition
	covergroup FunctionalCoverage;

		cvp_irq : coverpoint codix_ca_irq {
			bins zeros        = {0};
			bins ones         = {'b1};
		}

		// per instance statistics
		option.detect_overlap = 1;
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction : build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_input_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			codix_ca_irq = t.codix_ca_irq;
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_input_subscriber

// This class measures exercised combinations of DUTs output interface ports.
class codix_ca_output_subscriber extends ovm_subscriber #(codix_ca_output_transaction);

	// registration of component tools
	`ovm_component_utils( codix_ca_output_subscriber )

	// member attributes, equivalent with interface ports
	local logic codix_ca_port_halt;
	local logic [31:0] codix_ca_port_output;
	local logic codix_ca_port_output_en;
	local logic [31:0] codix_ca_port_error;

	// Covergroup definition
	covergroup FunctionalCoverage;

		cvp_port_halt : coverpoint codix_ca_port_halt {
			bins zeros        = {0};
			bins ones         = {'b1};
		}

		cvp_port_output : coverpoint codix_ca_port_output {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		cvp_port_output_en : coverpoint codix_ca_port_output_en {
			bins zeros        = {0};
			bins ones         = {'b1};
		}

		cvp_port_error : coverpoint codix_ca_port_error {
			bins zeros        = {0};
			bins ones         = {'b11111111111111111111111111111111};
			bins small_values = {[1:33'b011111111]};
			bins big_values   = {[33'b011111111111111111111111100000000:33'b011111111111111111111111111111110]};
			bins other_values[] = default;
		}

		// per instance statistics
		option.detect_overlap = 1;
		option.per_instance = 1;
	endgroup

	// Constructor - creates new instance of this class
	function new( string name, ovm_component parent );
		super.new( name, parent );
		FunctionalCoverage = new();
	endfunction: new

	// Build - instantiates child components
	function void build();
		super.build();
	endfunction : build

	// Write - obligatory function, samples value on the interface.
	function void write( codix_ca_output_transaction t );
		// skip invalid transactions
		if ( t.is_valid() )
		begin
			codix_ca_port_halt = t.codix_ca_port_halt;
			codix_ca_port_output = t.codix_ca_port_output;
			codix_ca_port_output_en = t.codix_ca_port_output_en;
			codix_ca_port_error = t.codix_ca_port_error;
			FunctionalCoverage.sample();
		end
	endfunction: write

endclass: codix_ca_output_subscriber

